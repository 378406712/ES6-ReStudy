# Generator 函数的异步应用

ES6 之前，异步编程的方法: 1.回调函数 2.事件监听 3.发布/订阅 4.Promise 对象

异步:简单说，就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回头执行第二段。
同步：连续的执行，不能插入其他任务。

## 回调函数

- JS 对异步变成的实现，就是回调函数：把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数，callback

**为什么 Node 约定，回调函数的第一个参数必须是错误对象 err（如果没有错误，该参数就是 null）？**

- 原因是执行分成两段，第一段执行完成以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当做参数，传入第二段。

## Promise

- 回调地狱(callback hell):代码多重嵌套，不是纵向发展，而是横向发展，多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。
- Promise 对象就是为了解决这个问题提出的，它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套改成链式调用。
- Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了，不管什么操作看上去都是一堆 then，原来的语义也变得很不清楚。

## Generator 函数

- 是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都要 yield 语句注明.
- next 方法的作用是分阶段执行 Generator 函数。每次调用 next 方法，会返回一个对象，表示当前阶段的信息（value 属性和 done 属性）.
- 封装异步任务的根本原因:Generator 函数可以暂停执行和恢复执行.

## Thunk 函数

- 自动执行 Generator 函数的一种方法
- 编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。
- JS 是传值调用的，它的 Thunk 函数含义有所不同。在 Js 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数.
- ES6 有了 Generator 函数，Thunk 函数现在可以用于 Generator 函数的自动流程管理。

## co 模块

- 用于 Generator 函数的自动执行。
- 使用 co 的前提条件是，Generator 函数的yield命令后面，只能是 Thunk 函数或 Promise 对象。如果数组或对象的成员，全部都是 Promise 对象，也可以使用 co
- 处理并发的异步操作,要把并发的操作都放在数组或对象里面，跟在yield语句后面。
